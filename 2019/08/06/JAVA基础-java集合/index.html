<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>JAVA基础-java集合 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="2019-08-06">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA基础-java集合">
<meta property="og:url" content="http://yoursite.com/2019/08/06/JAVA%E5%9F%BA%E7%A1%80-java%E9%9B%86%E5%90%88/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="2019-08-06">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2019-08-06T11:36:40.000Z">
<meta property="article:modified_time" content="2019-08-11T08:52:46.346Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.0.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-JAVA基础-java集合" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/06/JAVA%E5%9F%BA%E7%A1%80-java%E9%9B%86%E5%90%88/" class="article-date">
  <time datetime="2019-08-06T11:36:40.000Z" itemprop="datePublished">2019-08-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      JAVA基础-java集合
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="2019-08-06"><a href="#2019-08-06" class="headerlink" title="2019-08-06"></a>2019-08-06</h4><a id="more"></a>
<h2 id="集合的体系结构"><a href="#集合的体系结构" class="headerlink" title="集合的体系结构"></a>集合的体系结构</h2><ul>
<li><p>由于不同的数据结构（数据的组织，存储方式，所以Java为我们提供了不同的集合，但是不同的集合他们的功能都是相似的不断地往上提取，讲共性抽取出来，这就是集合体系结构形成的原因</p>
</li>
<li><p>集合只能存储对象，不能存放基本类型，存放基本类型可以使用其对应的包装类，在jdk1.5后面直接把基本类型写入集合，但是jdk会把其自动装箱成包装类</p>
</li>
<li><p>例如<br>Collection<br>List<br>ArrayList</p>
</li>
</ul>
<h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><ul>
<li>一个接口，有序的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class CollectionDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;collection是接口不能实例化，得利用多态；父类引用指向子类对象</span><br><span class="line">        Collection c &#x3D; new ArrayList();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        c.add(&quot;hello&quot;);</span><br><span class="line">        c.add(&quot;world&quot;);</span><br><span class="line">        System.out.println(c);&#x2F;&#x2F;[hello, world]</span><br><span class="line">        </span><br><span class="line">        c.clear();</span><br><span class="line">        System.out.println(c);&#x2F;&#x2F;[]</span><br><span class="line">        </span><br><span class="line">        c.add(&quot;hello&quot;);</span><br><span class="line">        c.add(&quot;java&quot;);</span><br><span class="line">        </span><br><span class="line">        System.out.println(c.contains(&quot;java&quot;));&#x2F;&#x2F;true</span><br><span class="line">        </span><br><span class="line">        System.out.println(c.remove(&quot;hello&quot;));&#x2F;&#x2F;true</span><br><span class="line">        System.out.println(c.remove(&quot;world&quot;));&#x2F;&#x2F;false</span><br><span class="line">        </span><br><span class="line">        System.out.println(c.size());&#x2F;&#x2F;1</span><br><span class="line">        </span><br><span class="line">        System.out.println(c.isEmpty());&#x2F;&#x2F;false</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        Object[] objs &#x3D; c.toArray();</span><br><span class="line">        for(int x &#x3D; 0; x&lt; c.size();x++) &#123;</span><br><span class="line">            </span><br><span class="line">            System.out.println(objs[x]);&#x2F;&#x2F;java</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="集合的迭代遍历"><a href="#集合的迭代遍历" class="headerlink" title="集合的迭代遍历"></a>集合的迭代遍历</h4><ul>
<li>toArray（）；按照数组的方式进行遍历</li>
<li>迭代器 iterator（）；可返回一个迭代器对象用于迭代集合；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> *   成员方法</span><br><span class="line"> *   E next() ;返回下一个元素</span><br><span class="line"> *   Boolean hasNext();  判断是否有元素可以获取</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class IteratorDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;多态，接口不能直接创建对象，可以利用多态的方法</span><br><span class="line">        Collection c &#x3D; new ArrayList();</span><br><span class="line">        </span><br><span class="line">        c.add(&quot;hello&quot;);</span><br><span class="line">        c.add(&quot;world&quot;);</span><br><span class="line">        c.add(&quot;java&quot;);</span><br><span class="line">        &#x2F;&#x2F;获取迭代器对象</span><br><span class="line">        Iterator it &#x3D; c.iterator();</span><br><span class="line">        </span><br><span class="line">        while(it.hasNext()) &#123;&#x2F;&#x2F;返回值为true时进行循环</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="并发修改异常"><a href="#并发修改异常" class="headerlink" title="并发修改异常"></a>并发修改异常</h4><ul>
<li>迭代器可以看成是集合的一个副本，迭代器在获取元素的时候并不是找集合去要，而是利用从自己的副本里面取出来，当迭代器在获取的时候发现和集合不一样，就会出现<strong>并发修改异常</strong></li>
<li>并发修改异常异常解决方法    ：在使用迭代器的时候用迭代器去修改,迭代器自身修改的时候会自动同步集合，就不会出现异常 。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Collection c &#x3D; new ArrayList();</span><br><span class="line"></span><br><span class="line">c.add(&quot;hello&quot;);</span><br><span class="line">c.add(&quot;world&quot;);</span><br><span class="line">c.add(&quot;java&quot;);</span><br><span class="line">&#x2F;&#x2F;获取迭代器对象</span><br><span class="line">Iterator it &#x3D; c.iterator();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while(it.hasNext()) &#123;</span><br><span class="line">    String s &#x3D; (String)it.next();</span><br><span class="line">    if(s.equals(&quot;java&quot;)) &#123;</span><br><span class="line">        c.add(&quot;android&quot;);&#x2F;&#x2F;修改了集合导致迭代器和集合的内容不一致</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="并发修改异常的解决"><a href="#并发修改异常的解决" class="headerlink" title="并发修改异常的解决"></a>并发修改异常的解决</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;多态，接口不能直接创建对象，可以利用多态的方法</span><br><span class="line">        List c &#x3D; new ArrayList();</span><br><span class="line">        &#x2F;&#x2F;用list接口下的迭代器有修改的成员方法</span><br><span class="line">        </span><br><span class="line">        c.add(&quot;hello&quot;);</span><br><span class="line">        c.add(&quot;world&quot;);</span><br><span class="line">        c.add(&quot;java&quot;);</span><br><span class="line">        &#x2F;&#x2F;获取迭代器对象</span><br><span class="line">        ListIterator lit &#x3D; c.listIterator();</span><br><span class="line">        while(lit.hasNext()) &#123;</span><br><span class="line">            String s &#x3D; (String)lit.next();</span><br><span class="line">            if(s.equals(&quot;java&quot;)) &#123;</span><br><span class="line">                lit.add(&quot;android&quot;);&#x2F;&#x2F;这里换成了迭代器自己去添加</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(c);</span><br></pre></td></tr></table></figure>

<h2 id="List（util）"><a href="#List（util）" class="headerlink" title="List（util）"></a>List<E>（util）</h2><ul>
<li>有序：储存和读取的顺序是一致的、有整数索引、允许重复的</li>
</ul>
<h4 id="list的常用的特有功能（相对于collection）"><a href="#list的常用的特有功能（相对于collection）" class="headerlink" title="list的常用的特有功能（相对于collection）"></a>list的常用的特有功能（相对于collection）</h4><ul>
<li>void add(int index, E element)<br>在列表中指定的位置上插入指定的元素,原本位置上的数据索引会前进一位</li>
<li>E get(int index)<br>返回此列表中指定位置的元素。 </li>
<li>E remove(int index)<br>移除此列表中指定位置的元素（可选操作）。 会把被移除的下一位之后的全部的索引减一位</li>
<li>E set(int index, E element)<br>用指定元素替换此列表中指定位置的元素（可选操作）。  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class ListDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        </span><br><span class="line">        List list &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        list.add(0,&quot;hello&quot;);</span><br><span class="line">        list.add(0,&quot;world&quot;);&#x2F;&#x2F;b把hello的索引从0变成了1</span><br><span class="line">        list.add(1,&quot;java&quot;);&#x2F;&#x2F;把hello的索引从1变成了2</span><br><span class="line">        </span><br><span class="line">        for(int x &#x3D; 0 ; x&lt;list.size();x++) &#123;</span><br><span class="line">            System.out.println(list.get(x) +&quot;&quot;+ x );</span><br><span class="line">            &#x2F;&#x2F;输出结果</span><br><span class="line">            &#x2F;&#x2F;world0</span><br><span class="line">            &#x2F;&#x2F;java1</span><br><span class="line">            &#x2F;&#x2F;hello2</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;-------------&quot;);</span><br><span class="line">        list.remove(0);</span><br><span class="line">        </span><br><span class="line">        for(int x &#x3D; 0 ; x&lt;list.size();x++) &#123;</span><br><span class="line">            System.out.println(list.get(x));</span><br><span class="line">&#x2F;&#x2F;            输出</span><br><span class="line">&#x2F;&#x2F;            java</span><br><span class="line">&#x2F;&#x2F;            hello</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;--------------&quot;);</span><br><span class="line">        </span><br><span class="line">        list.set(0, &quot;android&quot;);</span><br><span class="line">        </span><br><span class="line">        for(int x &#x3D; 0 ; x&lt;list.size();x++) &#123;</span><br><span class="line">            System.out.println(list.get(x));</span><br><span class="line">            &#x2F;&#x2F;输出，把Java改成了Android；</span><br><span class="line">            &#x2F;&#x2F;android</span><br><span class="line">            &#x2F;&#x2F;hello</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="list的常用子类"><a href="#list的常用子类" class="headerlink" title="list的常用子类"></a>list的常用子类</h4><ul>
<li>ArrayList：底层是数组结构；查找块增删慢</li>
<li>LinkedList：底层是链表；查询慢；增删快</li>
</ul>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><ul>
<li>自身有构造方法；可以new自身的对象</li>
</ul>
<p>####特有功能</p>
<ul>
<li>void addFirst(E e)</li>
<li>void addLast(E e)</li>
<li>E getFirst()</li>
<li>E getLast()</li>
<li>E removeFirst()</li>
<li>E removeLast()</li>
<li><strong>可以模拟一下栈或队列的结构</strong></li>
</ul>
<h2 id="set接口"><a href="#set接口" class="headerlink" title="set接口"></a>set接口</h2><ul>
<li>没有顺序，存取和读取的顺序<strong>有可能</strong>不一样</li>
<li>元素不能重复，要求元素唯一</li>
<li>没有索引</li>
</ul>
<h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><ul>
<li>没有索引</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 使用hashset存储字符串并遍历</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class HashSetDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        HashSet&lt;String&gt; hset &#x3D; new HashSet&lt;String&gt;();</span><br><span class="line">        </span><br><span class="line">        hset.add(&quot;hello&quot;);</span><br><span class="line">        hset.add(&quot;world&quot;);</span><br><span class="line">        hset.add(&quot;java&quot;);</span><br><span class="line">        &#x2F;&#x2F;采用迭代器的方法遍历</span><br><span class="line">        Iterator&lt;String&gt; it &#x3D; hset.iterator();</span><br><span class="line">        while (it.hasNext()) &#123;</span><br><span class="line">            String str &#x3D;  it.next();</span><br><span class="line">            System.out.println(str);    </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;-------&quot;);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;使用增强for进行遍历</span><br><span class="line">        for(String str: hset) &#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>hashset的add（）方法，首先会使用当前集合中的每一个元素和新添加的元素进行hash值的比较，如果hash值不一样，则直接添加新元素，如果hash值一样，就比较地址值或者使用equals方法进行比较，比较结果一样，则认为是重复不添加，所有比较结果一样则添加。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> *             利用hashset储存自定义对象并遍历</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class HashSetDemo2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        </span><br><span class="line">        HashSet&lt;Student&gt; hset &#x3D; new HashSet&lt;Student&gt;();</span><br><span class="line">        </span><br><span class="line">        Student s1 &#x3D; new Student(&quot;zhangsan&quot;, 14);</span><br><span class="line">        Student s2 &#x3D; new Student(&quot;lisi&quot;, 15);</span><br><span class="line">        Student s3 &#x3D; new Student(&quot;lisi&quot;, 15);</span><br><span class="line">        &#x2F;&#x2F;虽然s2s3的数据内容一样，当时add方法，没有重写hashcode（），默认比较的是地址值</span><br><span class="line">        &#x2F;&#x2F;两个元素的地址值本来就不一样，所以不被认为是重复的，于是没有去重</span><br><span class="line">        </span><br><span class="line">        hset.add(s1);</span><br><span class="line">        hset.add(s2);</span><br><span class="line">        hset.add(s3);</span><br><span class="line">        </span><br><span class="line">        for(Student s : hset) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">&#x2F;&#x2F;            输出结果</span><br><span class="line">&#x2F;&#x2F;            Student [name&#x3D;lisi, age&#x3D;15]</span><br><span class="line">&#x2F;&#x2F;            Student [name&#x3D;zhangsan, age&#x3D;14]</span><br><span class="line">&#x2F;&#x2F;            Student [name&#x3D;lisi, age&#x3D;15]</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>我们选择可以重写hashcode方法，让hashcode返回值返回 成员变量（除了Boolean）之和，student可以返回  return age+name.hashcode（）；</strong>，从而对算法效率进行优化，可以比较一连串不同类型数据的重复性。</li>
<li>eclipse可以快速生成重写hashcode方法和equals方法</li>
</ul>
<h2 id="collections"><a href="#collections" class="headerlink" title="collections"></a>collections</h2><ul>
<li>collections和collection的不同</li>
<li>collection是集合体系的最顶层，包括了集合体系的共性</li>
<li>collections是一个工具类构造私有，方法全是static方法，用于操作collection</li>
</ul>
<p>####一些常用的方法</p>
<ul>
<li>static <T> int binarySearch(List list, T key)<br>使用二叉搜索算法搜索指定对象的指定列表，参数里的T代表object<br>用二分法的前提条件，元素的是顺序排列的（所以参数只能是list不能是set）是元素的内容有序而不是元素的索引有序！，返回值就是T，如果没有查找到返回值是-T。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * 二分法</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class CollectionsDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">         List&lt;Integer&gt; list &#x3D; new ArrayList&lt;Integer&gt;();</span><br><span class="line">         </span><br><span class="line">         list.add(1);</span><br><span class="line">         list.add(5);</span><br><span class="line">         list.add(3);</span><br><span class="line">         list.add(4);</span><br><span class="line">         list.add(5);</span><br><span class="line">         list.add(7);</span><br><span class="line"></span><br><span class="line">         </span><br><span class="line">         int index &#x3D; Collections.binarySearch(list, 5);</span><br><span class="line">         </span><br><span class="line">         System.out.println(index);&#x2F;&#x2F;返回值是4索引4</span><br><span class="line">         &#x2F;&#x2F;因为二分法是直接从索引2开始对比</span><br><span class="line">         &#x2F;&#x2F;3小于5所以不会去看索引2之前的，如果这时候元素没有按顺序排列那么就会忽略索引1的5</span><br><span class="line">         &#x2F;&#x2F;继续比较就会得到索引4的5，就返回了索引4</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>static  void copy(List dest, List src)<br>将所有元素从一个列表复制**(覆盖）<strong>到另一个列表中。需要有序列表List，</strong>目的地列表必须至少与源列表一样长。 如果它更长，则目的地列表中的剩余元素不受影响**。 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list &#x3D; new ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">list.add(1);</span><br><span class="line">list.add(5);</span><br><span class="line">list.add(3);</span><br><span class="line">list.add(4);</span><br><span class="line">list.add(5);</span><br><span class="line">list.add(7);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">List&lt;Integer&gt; list2 &#x3D; new ArrayList&lt;Integer&gt;();</span><br><span class="line">list2.add(0);</span><br><span class="line">list2.add(0);</span><br><span class="line">list2.add(0);</span><br><span class="line">list2.add(0);</span><br><span class="line">list2.add(0);</span><br><span class="line">list2.add(0);</span><br><span class="line">list2.add(0);</span><br><span class="line">System.out.println(list2);&#x2F;&#x2F;[0, 0, 0, 0, 0, 0, 0]</span><br><span class="line">Collections.copy(list2, list);</span><br><span class="line">System.out.println(list);&#x2F;&#x2F;[1, 5, 3, 4, 5, 7]</span><br><span class="line">System.out.println(list2);&#x2F;&#x2F;[0, 0, 0, 0, 0, 0, 0]---&gt;覆盖写入[1, 5, 3, 4, 5, 7, 0]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>static  void fill(List&gt; list, Obeject obj)<br>用指定的元素代替指定列表的所有元素。 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;Integer&gt; list &#x3D; new ArrayList&lt;Integer&gt;();</span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line"> list.add(1);</span><br><span class="line"> list.add(5);</span><br><span class="line"> list.add(3);</span><br><span class="line"> list.add(4);</span><br><span class="line"> list.add(5);</span><br><span class="line"> list.add(7);</span><br><span class="line"> </span><br><span class="line"> Collections.fill(list, 99);</span><br><span class="line"> System.out.println(list);&#x2F;&#x2F;[99, 99, 99, 99, 99, 99]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>static void reverse(List list)<br>反转指定列表中元素的顺序。 用法和上面那个一样</p>
</li>
<li><p>static void shuffle(List&lt;?&gt; list, Random rnd)<br>使用指定的随机源随机排列指定的列表。不改变元素的内容，改变元素的顺序</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">        List&lt;Integer&gt; list &#x3D; new ArrayList&lt;Integer&gt;();</span><br><span class="line">         </span><br><span class="line">          </span><br><span class="line">         list.add(1);</span><br><span class="line">         list.add(5);</span><br><span class="line">         list.add(3);</span><br><span class="line">         list.add(4);</span><br><span class="line">         list.add(5);</span><br><span class="line">         list.add(7);</span><br><span class="line">         </span><br><span class="line">         System.out.println(list);&#x2F;&#x2F;[1, 5, 3, 4, 5, 7]</span><br><span class="line">         Collections.shuffle(list);</span><br><span class="line">         System.out.println(list);&#x2F;&#x2F;[7, 1, 3, 4, 5, 5]</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line"></span><br><span class="line">* public static  void sort(List&lt;T&gt; list)按自然顺序排列</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>    List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();


     list.add(1);
     list.add(5);
     list.add(3);
     list.add(4);
     list.add(5);
     list.add(7);
     System.out.println(list);//[1, 5, 3, 4, 5, 7]
     Collections.sort(list);
     System.out.println(list);//[1, 3, 4, 5, 5, 7]</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* static void swap(List&lt;?&gt; list, int i, int j) </span><br><span class="line">交换指定列表中指定位置的元素 </span><br><span class="line"></span><br><span class="line">* 斗地主案例</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>public class DouDiZhu {<br>    public static void main(String[] args) {<br>        ArrayList<String>  box = new ArrayList<String>();<br>        //写牌<br>        String[] str = {“草花”,”方片”,”黑桃”,”红桃”};<br>        String[] str2 = {“A”,”2”,”3”,”4”,”5”,”6”,”7”,”8”,”9”,”10”,”J”,”Q”,”K”};<br>        //对牌进行组合<br>        for (int i = 0; i &lt; str2.length; i++) {<br>            for (int j = 0; j &lt; str.length; j++) {<br>                box.add(str[j]+str2[i]);<br>            }<br>        }<br>        //添加两个特例<br>        box.add(“小王”);<br>        box.add(“大王”);<br>        System.out.println(box);</p>
<pre><code>    System.out.println(&quot;--------------------------&quot;);
    //洗牌打乱
    Collections.shuffle(box);

    System.out.println(box);
    //添加三个玩家容器
    ArrayList&lt;String&gt; player1 = new ArrayList&lt;String&gt;();
    ArrayList&lt;String&gt; player2 = new ArrayList&lt;String&gt;();
    ArrayList&lt;String&gt; player3 = new ArrayList&lt;String&gt;();
    //给三个玩家发牌
    for (int i = 0; i &lt; box.size()-3; i++) &#123;
        if( i%3 == 0) &#123;
            player1.add(box.get(i));
        &#125;
        else if (i%3 == 1) &#123;
            player2.add(box.get(i));
        &#125;
        else if (i%3 ==2 ) &#123;
            player3.add(box.get(i));
        &#125;

    &#125;

    System.out.println(&quot;------------&quot;);
    System.out.println(&quot;player1&quot;+player1);
    System.out.println(&quot;player2&quot;+player2);
    System.out.println(&quot;player3&quot;+player3);
    //亮底牌
    System.out.println(&quot;底牌是&quot;);
    for (int i = box.size()-3; i &lt; box.size(); i++) &#123;
        System.out.println(box.get(i));
    &#125;

&#125;</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## Map（K,V)接口</span><br><span class="line">* 实现具有对应关系的数据存储，比如学号和姓名</span><br><span class="line">* 映射键（学号）到值（姓名）的对象。一张Map不能包含重复的键，每个键可以映射到至多一个值</span><br><span class="line">* Map和Collection有什么区别呢  </span><br><span class="line">  Map是一个双列集合，常用于处理有对应关系的数据key是不可以重复的  </span><br><span class="line">  collection是一个单列集合，有不同的子体系</span><br><span class="line"></span><br><span class="line">#### 判断功能</span><br><span class="line">* boolean containsKey(Object key) ：判断指定的key是否存在</span><br><span class="line">* boolean containsValue(Object value) ：判断指定的value是否存在</span><br><span class="line">* boolean isEmpty()：判断map是否有映射关系  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 获取功能</span><br><span class="line">* V get(Object key) ：通过key得到value</span><br><span class="line">* int size() ：获取对应关系的对数</span><br><span class="line">* Set&lt;K&gt; keySet() :获取全部的key，返回值是set</span><br><span class="line">* Collection&lt;V&gt; values()：获取全部的value返回值是collection，</span><br><span class="line"></span><br><span class="line">#### 映射功能</span><br><span class="line">* V put(K key, V value): 就是将key键映射到value，如果key存在，则覆盖同key下的value，并返回被覆盖的、原来的那个value</span><br><span class="line"></span><br><span class="line">#### 遍历功能</span><br><span class="line">* Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() </span><br><span class="line"></span><br><span class="line">#### 删除功能</span><br><span class="line">* void clear() ：清楚所有的映射关系</span><br><span class="line">* V remove(Object key) ：通过key处删除对应的value，返回被删除的value的值，若key不存在返回null</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>public class MapDemo {</p>
<pre><code>public static void main(String[] args) &#123;

    Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();

    map.put(&quot;001&quot;, &quot;张三&quot;);
    map.put(&quot;002&quot;, &quot;李四&quot;);
    map.put(&quot;003&quot;, &quot;王五&quot;);

    System.out.println(map);//&#123;001=张三, 002=李四, 003=王五&#125;

    Set&lt;String&gt; set = map.keySet();
    for (String string : set) &#123;
        System.out.println(string);</code></pre>
<p>//            001<br>//            002<br>//            003<br>        }</p>
<pre><code>    Collection&lt;String&gt; values = map.values();
    for (String value : values) &#123;
        System.out.println(value);</code></pre>
<p>//            张三<br>//            李四<br>//            王五<br>        }</p>
<pre><code>    System.out.println(map.get(&quot;001&quot;));//张三

    System.out.println(map.remove(&quot;003&quot;));//王五
    System.out.println(map);//&#123;001=张三, 002=李四&#125;
    System.out.println(map.size());//2
    map.clear();
    System.out.println(map);//&#123;&#125;
    System.out.println(map.size());//0


&#125;</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* map的遍历方式</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>public static void main(String[] args) {<br>        //第一种遍历方式，先取出所有key然后用key去找每一个key对应的映射<br>        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();</p>
<pre><code>    map.put(&quot;001&quot;, &quot;zhangsan&quot;);
    map.put(&quot;002&quot;, &quot;lisi&quot;);
    map.put(&quot;003&quot;, &quot;wangsu&quot;);
    map.put(&quot;004&quot;, &quot;zhaoliu&quot;);

    Set&lt;String &gt; set = map.keySet();
    for (String key : set) &#123;
        String value = map.get(key);
        System.out.println(key+&quot;----&quot;+ value);</code></pre>
<p>//            001—-zhangsan<br>//            002—-lisi<br>//            003—-wangsu<br>//            004—-zhaoliu</p>
<pre><code>    &#125;</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* Set&lt;Map.Entry&lt;K,V&gt;&gt;  entrySet() :entry是set的内部类；返回值是set，泛型是Map.Entry&lt;K,V&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>    Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();

    map.put(&quot;001&quot;, &quot;zhangsan&quot;);
    map.put(&quot;002&quot;, &quot;lisi&quot;);
    map.put(&quot;003&quot;, &quot;wangsu&quot;);
    map.put(&quot;004&quot;, &quot;zhaoliu&quot;);

    Set&lt;Map.Entry&lt;String, String&gt;&gt; entrys = map.entrySet();

    for (Map.Entry&lt;String, String&gt; entry : entrys) &#123;
        String key = entry.getKey();
        String value = entry.getValue();
        System.out.println(key+&quot;----&quot;+value);
    &#125;</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## hashmap</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>public static void main(String[] args) {<br>        HashMap&lt;String, String&gt; hm = new HashMap&lt;String, String&gt;();</p>
<pre><code>    hm.put(&quot;001&quot;, &quot;李四&quot;);
    hm.put(&quot;002&quot;, &quot;李四&quot;);
    hm.put(&quot;003&quot;, &quot;王五&quot;);

    //第一种遍历方式
    Set&lt;String&gt; keys = hm.keySet();
    for (String key : keys) &#123;
        String value = hm.get(key);
        System.out.println(key+&quot;=&quot;+value);
    &#125;

    System.out.println(&quot;-----------&quot;);


    //第二种遍历方式
    Set&lt;Map.Entry&lt;String, String&gt;&gt; entrys = hm.entrySet();
    for (Map.Entry&lt;String, String&gt; entry : entrys) &#123;
        String key = entry.getKey();
        String value = entry.getValue();
        System.out.println(key+&quot;=&quot;+value);
    &#125;
&#125;</code></pre>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 自定义对象作为key时的hashmap储存</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>public class Student {<br>    String name;<br>    int age ;</p>
<pre><code>public Student(String name, int age) &#123;
    this.name = name;
    this.age = age;
&#125;


@Override
public String toString() &#123;
    return &quot;Student [name=&quot; + name + &quot;, age=&quot; + age + &quot;]&quot;;
&#125;


@Override
public int hashCode() &#123;
    final int prime = 31;
    int result = 1;
    result = prime * result + age;
    result = prime * result + ((name == null) ? 0 : name.hashCode());
    return result;
&#125;


@Override
public boolean equals(Object obj) &#123;
    if (this == obj)
        return true;
    if (obj == null)
        return false;
    if (getClass() != obj.getClass())
        return false;
    Student other = (Student) obj;
    if (age != other.age)
        return false;
    if (name == null) &#123;
        if (other.name != null)
            return false;
    &#125; else if (!name.equals(other.name))
        return false;
    return true;
&#125;</code></pre>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 主程序</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>public class HashMapDemo2 {<br>    public static void main(String[] args) {<br>        HashMap&lt;Student, Integer&gt; hm  = new HashMap&lt;Student, Integer&gt;();</p>
<pre><code>    Student s1 = new Student(&quot;zhangsan&quot;, 12);
    Student s2 = new Student(&quot;lisi&quot;, 19);
    Student s3 = new Student(&quot;wangwu&quot;, 23);

    hm.put(s1, 001);
    hm.put(s2, 002);
    hm.put(s3, 003);

    //遍历方式1
    Set&lt;Student&gt; keys = hm.keySet();
    for (Student key : keys) &#123;
        Integer value = hm.get(key);
        System.out.println(key+&quot;---&quot;+value);
    &#125;

    System.out.println(&quot;==================&quot;);

    //遍历方式2
    Set&lt;Map.Entry&lt;Student, Integer&gt;&gt; entrys = hm.entrySet();
    for (Map.Entry&lt;Student, Integer&gt; entry : entrys) &#123;
        Student key = entry.getKey();
        Integer value = entry.getValue();

        System.out.println( key +&quot;=&quot;+value);
    &#125;


&#125;</code></pre>
<p>}</p>
<p>```</p>
<h2 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h2><ul>
<li>实现了map，是一个双列集合</li>
<li>Properties类表示一组持久的属性，性列表中的每个键及其对应的值都是一个字符串</li>
</ul>
<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><ul>
<li>Properties()<br>创建一个没有默认值的空属性列表。</li>
</ul>
<h4 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h4><ul>
<li>void list(PrintWriter out)<br>将此属性列表打印到指定的输出流。 </li>
<li>void list(PrintStream out)<br>将此属性列表打印到指定的输出流。 </li>
<li>void load(InputStream inStream)<br>从输入字节流读取属性列表（键和元素对）。</li>
<li>void load(Reader reader)<br>以简单的线性格式从输入字符流读取属性列表（关键字和元素对）。</li>
<li>void store(Writer writer, String comments)<br>将此属性列表（键和元素对）写入此 Properties表中，以适合使用 load(Reader)方法的格式输出到输出字符流。<strong>后面那个参数comments是用于描述文本，会在文件头出现。可以置为null</strong> </li>
<li>void store(Writer writer, String comments)<br>将此属性列表（键和元素对）写入此 Properties表中，以适合使用 load(Reader)方法的格式输出到输出字符流。     </li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/06/JAVA%E5%9F%BA%E7%A1%80-java%E9%9B%86%E5%90%88/" data-id="cke24uzy1000qq0uafpjl5iyw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/08/06/JAVA%E5%9F%BA%E7%A1%80-%E6%B3%9B%E5%9E%8B/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          JAVA基础-泛型及常见简单数据结构
        
      </div>
    </a>
  
  
    <a href="/2019/07/28/JAVA%E5%9F%BA%E7%A1%80-I-O%E6%B5%81/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">JAVA基础-I/O流</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Green-MD%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" rel="tag">Green MD基础语法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" rel="tag">JAVA语言基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/" rel="tag">Java程序流程控制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B8%B8%E7%94%A8%E7%B1%BB/" rel="tag">常用类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E7%BB%84%E4%B8%8E%E6%96%B9%E6%B3%95/" rel="tag">数组与方法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/" rel="tag">面向对象设计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/" rel="tag">面向对象设计基础</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Green-MD%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" style="font-size: 10px;">Green MD基础语法</a> <a href="/tags/JAVA%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">JAVA语言基础</a> <a href="/tags/Java%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/" style="font-size: 10px;">Java程序流程控制</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/%E5%B8%B8%E7%94%A8%E7%B1%BB/" style="font-size: 10px;">常用类</a> <a href="/tags/%E6%95%B0%E7%BB%84%E4%B8%8E%E6%96%B9%E6%B3%95/" style="font-size: 10px;">数组与方法</a> <a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/" style="font-size: 10px;">面向对象设计</a> <a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">面向对象设计基础</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/08/19/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2020/06/22/Git%E5%AD%A6%E4%B9%A0/">Git学习</a>
          </li>
        
          <li>
            <a href="/2020/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/">计算机网络笔记</a>
          </li>
        
          <li>
            <a href="/2020/02/04/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Spring学习笔记</a>
          </li>
        
          <li>
            <a href="/2019/10/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/">计算机组成原理学习笔记(1)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>