<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>JAVA基础-面向对象设计(2) | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="2019-7-27">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA基础-面向对象设计(2)">
<meta property="og:url" content="http://yoursite.com/2019/07/27/JAVA%E5%9F%BA%E7%A1%80-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A12/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="2019-7-27">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2019-07-27T05:48:55.000Z">
<meta property="article:modified_time" content="2019-08-04T02:14:57.228Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="面向对象设计">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.0.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-JAVA基础-面向对象设计2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/27/JAVA%E5%9F%BA%E7%A1%80-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A12/" class="article-date">
  <time datetime="2019-07-27T05:48:55.000Z" itemprop="datePublished">2019-07-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      JAVA基础-面向对象设计(2)
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="2019-7-27"><a href="#2019-7-27" class="headerlink" title="2019-7-27"></a>2019-7-27</h4><a id="more"></a>

<h2 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h2><ul>
<li>对多个对象进行操作，就必须对多个对象进行存储，不能是一个基本的变量，而是一个容器类型的变量  </li>
<li>集合类长度可变</li>
</ul>
<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList<E></h2><ul>
<li>ArrayList<E><br>这个E代表泛型，在出现E的地方我们使用数据类型替换即可</li>
</ul>
<h4 id="构造方法-ArrayList"><a href="#构造方法-ArrayList" class="headerlink" title="构造方法 ArrayList()"></a>构造方法 ArrayList()</h4><p>构造一个初始容量为十的空列表。<br>例如ArraryList<String> arrary = new ArraryList<String>();</p>
<h4 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h4><ul>
<li>添加元素  </li>
</ul>
<p>1.public boolean add(E):这里的E随集合创建时而改变<br>2.public void add(int index,E element):在指定索引处添加一个元素，该位置的原有元素不会被删掉，而是整体向后加一个索引</p>
<ul>
<li>获取元素<br>public E get(int index) 返回此列表中指定位置的元素。</li>
<li>集合长度<br>public int size() 返回此列表中元素的数目。 </li>
<li>删除元素<br>public boolean remove(Object o):删除指定元素返回是否成功<br>public E remove(int index)：删除指定索引处的元素，返回被删除的元素</li>
<li>修改元素  </li>
<li>public E set(int index,E element):修改指定索引处的元素，放回被修改的元素  </li>
</ul>
<h4 id="集合的遍历"><a href="#集合的遍历" class="headerlink" title="集合的遍历"></a>集合的遍历</h4><ul>
<li>用元素获取的方法，for循环次数用size（）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(int x&#x3D; 0;x&lt;array.size();x++)&#123;  </span><br><span class="line">    System.out.println(array.get(x));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><ul>
<li>局部代码块：存在于方法中，控制变量的生命周期（作用域），节省内存</li>
<li>构造代码块：提取构造方法中的共性，每次创建对象都会执行，并且再构造方法执行之前执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Teacher &#123;</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line">    &#x2F;&#x2F;创建一个构造代码块，每构造一次对象，就会执行一次构造代码块</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;我是构造代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public Teacher() &#123;</span><br><span class="line">        System.out.println(&quot;我是无参构造&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public Teacher(String name, int age) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;我是有参构造&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class BlockDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Teacher tc1 &#x3D; new Teacher();&#x2F;&#x2F;无参构造</span><br><span class="line">        Teacher tc2 &#x3D; new Teacher(&quot;李&quot;, 36);&#x2F;&#x2F;有参构造</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;运行结果为：</span><br><span class="line">&#x2F;&#x2F;我是构造代码块</span><br><span class="line">&#x2F;&#x2F;我是无参构造</span><br><span class="line">&#x2F;&#x2F;我是构造代码块</span><br><span class="line">&#x2F;&#x2F;我是有参构造</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>静态代码块：随着类的加载而加载，只加载一次，加载类需要的的初始化，比如加载驱动</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Teacher &#123;</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line">    &#x2F;&#x2F;创建一个静态代码块，随着类的加载而加载 ，用于必要的初始化</span><br><span class="line">    static&#123;</span><br><span class="line">        System.out.println(&quot;我是构造代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public Teacher() &#123;</span><br><span class="line">        System.out.println(&quot;我是无参构造&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public Teacher(String name, int age) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;我是有参构造&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class BlockDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Teacher tc1 &#x3D; new Teacher();&#x2F;&#x2F;无参构造</span><br><span class="line">        Teacher tc2 &#x3D; new Teacher(&quot;李&quot;, 36);&#x2F;&#x2F;有参构造</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;运行结果为：</span><br><span class="line">&#x2F;&#x2F;我是构造代码块</span><br><span class="line">&#x2F;&#x2F;我是无参构造</span><br><span class="line">&#x2F;&#x2F;我是有参构造</span><br><span class="line">&#x2F;&#x2F;相比构造代码块，静态代码块不论创建多少个对象，静态代码块只执行一次</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>如果一个类中同时有静态代码块，构造代码块，构造方法，那么在创建该类的对象是，首先执行静态代码块–&gt;构造代码块–&gt;构造方法</li>
</ul>
<h2 id="this和super的区别"><a href="#this和super的区别" class="headerlink" title="this和super的区别"></a>this和super的区别</h2><ul>
<li>this<br>当前对象的引用，调用子类的成员变量和子类的成员方法，在子类构造第一行调用子类或父类的方法</li>
<li>super<br>子类对象的父类引用，调用父类的成员变量和方法，在子类的第一行调用父类的构造方法</li>
</ul>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ul>
<li>abstract:关键字，用于修饰方法和类</li>
<li>抽象方法：不同类的方法时相似的，但是内容又不太一致，<br>我们只抽取他的声明，没有具体的方法体，也称为：未实现的方法</li>
<li>抽象类：有抽象方法的类必须是抽象类</li>
<li>注意：一个类继承了抽象类，必须重写他所有的抽象方法，否则这个类就得是抽象类</li>
</ul>
<h4 id="抽象类的特点"><a href="#抽象类的特点" class="headerlink" title="抽象类的特点"></a>抽象类的特点</h4><ul>
<li>抽象方法只能在抽象类里面，抽象类与抽象方法必须被abstract修饰</li>
<li>抽象类不能创建对象（不能实例化）；</li>
<li>抽象类中可以有非抽象方法</li>
<li>抽象类和类的关系也是继承<br>一个类继承了抽象类，要么重写所有的抽象方法，子类仍是普通类，要么他自己是抽象类。</li>
<li>抽象类是有构造方法的，作用是给成员变量进行初始化</li>
<li>abstract 和final不能共存，不能和private共存</li>
<li>父类是抽象类，子类只要不调用抽象方法就不一定要是抽象类</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul>
<li><strong>用于处理继承单一的局限性</strong></li>
<li>接口是一个比抽象类还抽象的类，接口里的所用方法全是抽象方法（就算你在写方法的时候不加abstract，也默认强制给你加上）<br>接口和类的关系不是继承，而是实现（把接口的方法都实现）：implements</li>
<li>格式 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface Animal&#123;</span><br><span class="line">    public abstract void eat（）；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接口成员特点"><a href="#接口成员特点" class="headerlink" title="接口成员特点"></a>接口成员特点</h4><ul>
<li>只能有抽象方法，所以不能创建对象（实例化）</li>
<li>只能有常量，默认用public static final来修饰成员变量</li>
<li>只能使用public abstract 修饰方法</li>
<li>类与接口的关系是实现关系，一个类实现一个接口必须实现他所有的方法</li>
</ul>
<h4 id="类与接口之间的关系"><a href="#类与接口之间的关系" class="headerlink" title="类与接口之间的关系"></a>类与接口之间的关系</h4><ul>
<li>类与类之间：继承关系，单一继承，多层继承</li>
<li>类与接口：实现关系，多实现</li>
<li>接口与接口之间的关系，继承关系，可以多层继承</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#96;interface InterA&#123;</span><br><span class="line">&#125;</span><br><span class="line">inerface InterB&#123;</span><br><span class="line">&#125;</span><br><span class="line">class Demo implements InterA,InterB&#123;&#x2F;&#x2F;Demo 用了两个接口，多实现</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">interface InterA extends InterB&#123;</span><br><span class="line">&#x2F;&#x2F;接口与接口之间是继承关系，实现子类的同时也要实现父类的方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h4><ul>
<li>共性：不断地抽取出抽象的概念</li>
<li>区别1：与类之间的关系，类与接口时多实现关系，类与抽象类时单一多层继承  </li>
<li>区别2：成员变量：抽象类可以有成员变量也可以用常量，接口只有常量<br>成员方法：抽象类可以有抽象方法，也可以有非抽象方法；接口只能有抽象方法，而且方法有默认修饰符public abstract<br>构造方法： 抽象类有构造方法，接口没有构造方法</li>
</ul>
<h2 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h2><ul>
<li>没有变量引用对象</li>
<li>匿名对象应用场景：1当方法只调用一次时就可以使用；  </li>
</ul>
<p>2.可以当作参数进行传递，但是无法在传参之前做其他的事情；</p>
<ul>
<li>匿名对象可以调用成员变量并且赋值，但赋值没有意义</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new Student().age &#x3D; 18</span><br><span class="line">System.out.println(new Studen().age);</span><br><span class="line">&#x2F;&#x2F;输出仍是0，因为new了两个对象，这两个对象是不同的，所以赋值没有意义</span><br></pre></td></tr></table></figure>

<h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><ul>
<li>修饰符，可以修饰类，成员方法、成员变量；</li>
<li>final所修饰的类，不能被继承，不能有子类</li>
<li>final所修饰的方法，不能被重写，不需要子类去完善</li>
<li>final所修饰的变量，值不能被修改，是自定义常量，命名一般全是大写，自定义常量必须初始化，可以选择显示初始化或构造初始化</li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul>
<li>多态的前提条件： 子父类的继承关系；方法的重写；父类引用指向子类对象  </li>
<li>父类引用指向子类对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class PoymorphicDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;父类引用    指向   子类对象</span><br><span class="line">        Animal a &#x3D; new Cat();</span><br><span class="line">        a.eat();&#x2F;&#x2F;这里eat调用的是子类的方法，动态绑定        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Animal&#123;</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;恰饭&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cat extends Animal&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void eat() &#123;</span><br><span class="line">        System.out.println(&quot;猫恰鱼&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void speak() &#123;</span><br><span class="line">        System.out.println(&quot;喵喵喵&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>动态绑定：运行期间调用的方法是根据其具体的类型（Cat）所以调用的是子类cat的eat（）；</li>
</ul>
<h4 id="多态的成员特点"><a href="#多态的成员特点" class="headerlink" title="多态的成员特点"></a>多态的成员特点</h4><ul>
<li>成员变量：编译时看的是左边，运行时看的还是左边，成员变量没有重写的概念</li>
<li>成员变量：编译时看左边，运行时看右边，有动态绑定</li>
<li>静态方法static:编译时看左边，运行时看的还是左边，使用变量去调用静态方法，相当于用变量的类名去调用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    Dad dad &#x3D; new Kid();</span><br><span class="line">    System.out.println(d.num);&#x2F;&#x2F;输出的还是20，</span><br><span class="line">   ...</span><br><span class="line">class Dad &#123;</span><br><span class="line">    int num &#x3D; 20;</span><br><span class="line">&#125;</span><br><span class="line">class Kid&#123;</span><br><span class="line">    int num &#x3D; 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="引用类型之间的转换"><a href="#引用类型之间的转换" class="headerlink" title="引用类型之间的转换"></a>引用类型之间的转换</h4><ul>
<li>向上转型（自动），由小到大，子类型转成父类型 ，<br><strong>转型后只能调用父类的方法，但是执行效果因为动态绑定还是执行具体对象的方法（除去static方法）</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal a &#x3D; new Dog();&#x2F;&#x2F;（向上转型，子类型转成父类型）</span><br></pre></td></tr></table></figure>

<ul>
<li>向下转型（强制），由大到小，父类型转成子类型，<br><strong>本身是什么类型，你才能转化什么类型Dog–&gt;Animal–&gt;Dog，而不能Cat–&gt;Animal–&gt;Dog</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Animal a &#x3D; new Dog();</span><br><span class="line">Dog d &#x3D; (Dog)a;&#x2F;&#x2F;强制转换，向下转型，把父类Animal转成子类Dog</span><br><span class="line"></span><br><span class="line">d.swim();&#x2F;&#x2F;调用子类独有方法swim</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="多态优缺点"><a href="#多态优缺点" class="headerlink" title="多态优缺点"></a>多态优缺点</h4><ul>
<li>缺点：无法直接访问子类特有的成员，只能采取向下转型的方法</li>
<li>优点，提高可维护性（多态前提所保证的），提高代码的可扩展性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class PoymorphicDemo2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MiFactory factory &#x3D; new MiFactory();</span><br><span class="line">        factory.createPhone(new MiNote());</span><br><span class="line">        </span><br><span class="line">        factory.createPhone(new RedMi()); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Phone&#123;</span><br><span class="line">    public void call();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MiFactory&#123;</span><br><span class="line">&#x2F;*    public void createPhone(MiNote mi) &#123;</span><br><span class="line">        mi.call();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;如果这样，每更新一部手机就需要添加一个重载方法，不方便</span><br><span class="line">    public void createPhone(RedMi mi) &#123;</span><br><span class="line">        mi.call();</span><br><span class="line">    &#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">    public void createPhone(Phone p) &#123;</span><br><span class="line">        p.call();&#x2F;&#x2F;只需要这一个方法就行了,把父类型当作参数就行了</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;*</span><br><span class="line">class MiNote &#123;</span><br><span class="line">    public void call() &#123;</span><br><span class="line">        System.out.println(&quot;小米手机打电话&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class RedMi&#123;</span><br><span class="line">    public void call() &#123;</span><br><span class="line">        System.out.println(&quot;红米打电话&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">class MiNote implements Phone&#123;&#x2F;&#x2F;把手机实现接口，以后再MiFacetory</span><br><span class="line">&#x2F;&#x2F;中不需要重载方法了</span><br><span class="line">    public void call() &#123;</span><br><span class="line">        System.out.println(&quot;小米手机打电话&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class RedMi implements Phone&#123;</span><br><span class="line">    public void call() &#123;</span><br><span class="line">        System.out.println(&quot;红米打电话&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><ul>
<li>可以有多层结构</li>
<li>不同包下的文件名可以重复</li>
<li>包的声明必须是第一行代码</li>
</ul>
<h4 id="包间相互访问"><a href="#包间相互访问" class="headerlink" title="包间相互访问"></a>包间相互访问</h4><ul>
<li>相同包下的类可以直接访问，不需要其他操作</li>
<li>类的全名 ：包名.类名</li>
<li>不同包下<br>当类没有写全名的话就在当前包下去找<br>1.使用类的全名<br>2.使用关键字impot导入，”<em>“ 代表导入了这个包下的所有类，并没有导入子包下面的类<br>java.util.</em>:代表导入了util下的所有类，但是并没有导入子包  </li>
</ul>
<h2 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h2><table>
<thead>
<tr>
<th>———–</th>
<th>当前类</th>
<th>相同包下不同的类</th>
<th>不同包下的类</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>default</td>
<td>√</td>
<td>√</td>
<td>-</td>
</tr>
<tr>
<td>private</td>
<td>√</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>-</td>
</tr>
</tbody></table>
<p>default是用于当前包下使用<br>protected：让子类对象使用</p>
<h2 id="修饰符总结"><a href="#修饰符总结" class="headerlink" title="修饰符总结"></a>修饰符总结</h2><table>
<thead>
<tr>
<th>修饰符</th>
<th>类</th>
<th>成员变量</th>
<th>成员方法</th>
<th>构造方法</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>default</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>protected</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>private</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>abstract</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>static</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
<tr>
<td>final</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
</tr>
</tbody></table>
<ul>
<li><strong>常见</strong>的规则：<br>以后我们使用public来修饰类，一个Java文件建议只能有一个类<br>如果一个文件有多个类，和文件名相同的哪个类，必须用public修饰，其他的类不能使用public修饰<br>以后所有的成员变量都使用private修饰，必须提供public的getter和setter方法<br>以后所有的方法想公用用public，想私有用就private，想只要子类用就protected<br>以后所有的构造方法用public修饰，不想让创建对象，用private修饰</li>
</ul>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ul>
<li>内部类仍然是一个独立的类，在编译之后内部类会编译成独立的.class文件，但是前面冠以外部类的类名和$符号</li>
<li>内部类不能用普通的方式访问，内部类是外部类的一个成员，因此内部类可以自由地访问外部类的成员变量，无论是否是private</li>
</ul>
<h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><ul>
<li>在类的成员位置，和成员变量和成员方法的位置是一样的</li>
<li>在内部类当中，可以直接访问外部类的所有成员</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class InnerDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F;Outer o &#x3D; new Outer();</span><br><span class="line">        &#x2F;&#x2F;o.method();&#x2F;&#x2F;输出10</span><br><span class="line">        </span><br><span class="line">        Outer.Inner i  &#x3D; new Outer().new Inner();</span><br><span class="line">        &#x2F;&#x2F;这里在是同一个包下，可以直接打全名，在不同包可以选择导包</span><br><span class="line">        &#x2F;&#x2F;创建的对象是内部类的对象i，创建后可以直接调用Inner面的方法</span><br><span class="line">        i.function();&#x2F;&#x2F;输出还是10</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Outer&#123;</span><br><span class="line">    private int num &#x3D; 10;</span><br><span class="line">    </span><br><span class="line">    public void method() &#123;</span><br><span class="line">        Inner i &#x3D;  new Inner();&#x2F;&#x2F;在外部类的方法中创建对象来访问内部类</span><br><span class="line">        i.function();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    class Inner&#123;&#x2F;&#x2F;这就是内部类</span><br><span class="line">        public void function() &#123;</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>成员内部类的修饰符：<br>如果内部类用private修饰，在外部类中可以调用，但是在其他类中不能访问，这和私有成员，私有方法性质一致<br>如果内部类是static，直接new内部类的对象就行了，不用new外部类的对象了</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Outer.Inner i  &#x3D; new Outer().new Inner();&#x2F;&#x2F;内部类不为static，外部类对象和内部类对象都要new</span><br><span class="line">Outer.Inner i  &#x3D; new Outer().Inner();只需要new内部类对象</span><br></pre></td></tr></table></figure>


<h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><ul>
<li>在方法内，出了方法之后就无法使用,性质和局部变量一致，生命周期也一致</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Outer2&#123;</span><br><span class="line">    public void method() &#123;</span><br><span class="line">        int num &#x3D; 10;&#x2F;&#x2F;局部变量</span><br><span class="line">        class Inner&#123;&#x2F;&#x2F;局部类</span><br><span class="line">            public void function() &#123;&#x2F;&#x2F;局部类中的方法</span><br><span class="line">                System.out.println(&quot;function&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><ul>
<li>可以看做内部类看成是一个<strong>没有名字的局部内部类</strong></li>
<li>定义在方法中</li>
<li>必须在定义匿名内部类的时候创建对象</li>
<li>格式  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new 类&#x2F;接口 （）&#123;</span><br><span class="line">    &#x2F;&#x2F;如果是创建了这个类的子类对象，我们可以重新写父类的方法</span><br><span class="line">    &#x2F;&#x2F;如果是创建了这个接口的子类对象，我们必须实现接口的所有方法</span><br><span class="line"></span><br><span class="line">&#125;；</span><br><span class="line">&#x2F;&#x2F;原理创建了继承这个类的子类对象或者创建了实现了这个几口的子类对象</span><br></pre></td></tr></table></figure>

<ul>
<li>应用场景：作为参数进行传递</li>
</ul>
<h2 id="object类"><a href="#object类" class="headerlink" title="object类"></a>object类</h2><ul>
<li>类层次结构的根，即没有继承任何类的类默认继承objecct，可以调用object方法</li>
</ul>
<h4 id="String-toString"><a href="#String-toString" class="headerlink" title="String toString();"></a>String toString();</h4><ul>
<li>返回该对象的字符串表示</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * String toString();返回该对象的字符串表示</span><br><span class="line"> *     return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());</span><br><span class="line"> *   getClass()返回一个字节码对象       </span><br><span class="line"> *   Integer.toHexString(hashCode());返回指定参数（哈希码值内存地址）的十六进制数      </span><br><span class="line"> * </span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ObjectDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Student s &#x3D; new Student();</span><br><span class="line">        s.age&#x3D;33;</span><br><span class="line">        s.name &#x3D; &quot;张三&quot;;</span><br><span class="line">        System.out.println(s.toString());&#x2F;&#x2F;com.gy_1.Student@15db9742</span><br><span class="line">        System.out.println(s);&#x2F;&#x2F;com.gy_1.Student@15db9742</span><br><span class="line">        &#x2F;&#x2F;重写toString方法后就输出我们需要的toString方法</span><br><span class="line">        &#x2F;&#x2F;可以利用编译器快速编写toSring方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends Object&#123;</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;重写toString方法</span><br><span class="line">&#x2F;*    public String toString&#123;</span><br><span class="line">        return name +&quot;@&quot; + age</span><br><span class="line">    &#125;*&#x2F;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;鼠标右键-&gt;source-&gt;generate toSring();</span><br><span class="line">        @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Student [name&#x3D;&quot; + name + &quot;, age&#x3D;&quot; + age + &quot;]&quot;;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="boolean-equals-Object-obj"><a href="#boolean-equals-Object-obj" class="headerlink" title="boolean equals(Object obj)"></a>boolean equals(Object obj)</h4><ul>
<li>eclipse中查询源码 crtl+shift+T输入类名  然后crtl+O进行检索方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * boolean equals(Object obj)</span><br><span class="line"> *         使用&#x3D;&#x3D;来比较两个对象是否相等，基本类型是比较值是否相等</span><br><span class="line"> *         引用类型是比较地址值是否相等</span><br><span class="line"> *         要用的话基本上就得重写</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class ObjectDemo2 &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Person p &#x3D; new Person(&quot;张三&quot;, 18);</span><br><span class="line">        Person p2 &#x3D; new Person(&quot;张三&quot;, 18);</span><br><span class="line">        &#x2F;&#x2F;如果没有重写equals（）那么比较的是地址值，肯定是不同的，没有太多的意义</span><br><span class="line">        &#x2F;&#x2F;重写后返回true</span><br><span class="line">        boolean flag &#x3D; p.equals(p2);</span><br><span class="line">        System.out.println(flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person&#123;</span><br><span class="line">    String name;</span><br><span class="line">    int age;</span><br><span class="line">    public Person(String name,int age) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;*    @Override</span><br><span class="line">    public boolean equals(Object obj) &#123;</span><br><span class="line">        &#x2F;&#x2F;提高效率，如果当前对象和传递进来的地址值一样，直接返回true</span><br><span class="line">        if(this &#x3D;&#x3D; obj) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;提高代码的安全性,如果传递进来的参数不是person类，直接返回false</span><br><span class="line">        &#x2F;&#x2F;</span><br><span class="line">        if(this.getClass() !&#x3D; obj.getClass()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;父类型看不见子类型的私有成员，所以要向下转型</span><br><span class="line">        Person other &#x3D; (Person) obj;</span><br><span class="line">        if(!this.name.equals(other.name)) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(this.age !&#x3D; other.age) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;*&#x2F;</span><br><span class="line">    &#x2F;&#x2F;eclipse有快捷方式generate hashCode（）and equals（）；</span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object obj) &#123;</span><br><span class="line">        if (this &#x3D;&#x3D; obj)</span><br><span class="line">            return true;</span><br><span class="line">        if (obj &#x3D;&#x3D; null)</span><br><span class="line">            return false;</span><br><span class="line">        if (getClass() !&#x3D; obj.getClass())</span><br><span class="line">            return false;</span><br><span class="line">        Person other &#x3D; (Person) obj;</span><br><span class="line">        if (age !&#x3D; other.age)</span><br><span class="line">            return false;</span><br><span class="line">        if (name &#x3D;&#x3D; null) &#123;</span><br><span class="line">            if (other.name !&#x3D; null)</span><br><span class="line">                return false;</span><br><span class="line">        &#125; else if (!name.equals(other.name))</span><br><span class="line">            return false;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/27/JAVA%E5%9F%BA%E7%A1%80-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A12/" data-id="cke24uzy2000rq0uafz5ncxn5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/" rel="tag">面向对象设计</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/07/28/JAVA%E5%9F%BA%E7%A1%80-I-O%E6%B5%81/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          JAVA基础-I/O流
        
      </div>
    </a>
  
  
    <a href="/2019/07/21/JAVA%E5%9F%BA%E7%A1%80-%E5%B8%B8%E7%94%A8%E7%B1%BB/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">JAVA基础-常用类</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Green-MD%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" rel="tag">Green MD基础语法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" rel="tag">JAVA语言基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/" rel="tag">Java程序流程控制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B8%B8%E7%94%A8%E7%B1%BB/" rel="tag">常用类</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E7%BB%84%E4%B8%8E%E6%96%B9%E6%B3%95/" rel="tag">数组与方法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/" rel="tag">面向对象设计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/" rel="tag">面向对象设计基础</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Green-MD%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/" style="font-size: 10px;">Green MD基础语法</a> <a href="/tags/JAVA%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">JAVA语言基础</a> <a href="/tags/Java%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/" style="font-size: 10px;">Java程序流程控制</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/%E5%B8%B8%E7%94%A8%E7%B1%BB/" style="font-size: 10px;">常用类</a> <a href="/tags/%E6%95%B0%E7%BB%84%E4%B8%8E%E6%96%B9%E6%B3%95/" style="font-size: 10px;">数组与方法</a> <a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/" style="font-size: 10px;">面向对象设计</a> <a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80/" style="font-size: 10px;">面向对象设计基础</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/08/19/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2020/06/22/Git%E5%AD%A6%E4%B9%A0/">Git学习</a>
          </li>
        
          <li>
            <a href="/2020/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/">计算机网络笔记</a>
          </li>
        
          <li>
            <a href="/2020/02/04/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Spring学习笔记</a>
          </li>
        
          <li>
            <a href="/2019/10/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/">计算机组成原理学习笔记(1)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>